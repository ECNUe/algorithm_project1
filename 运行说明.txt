================================================================================
                  智慧港口自动化调度系统 - 运行说明
================================================================================

【项目简介】

本项目模拟一个全自动港口的机器人调度系统。你需要编写算法控制10个机器人
和5艘轮船，在100×100的地图上搬运货物，最大化收益。

核心算法考点：最短路（BFS/A*）、贪心调度、多机器人冲突避免

================================================================================
【环境要求】
================================================================================

- Python 3.6+
- g++ 编译器（支持 C++11）
- Windows / Linux / MacOS 均可

================================================================================
【快速开始 - 三步运行】
================================================================================

第一步：生成地图
    python gen_map.py

    运行后会在 maps/ 文件夹下生成：
    - map1.txt      100×100的港口地图

第二步：编译你的代码
    Windows:    g++ main.cpp -o main.exe -std=c++11
    Linux/Mac:  g++ main.cpp -o main -std=c++11

第三步：运行判题器评测
    python judge.py

================================================================================
【评分机制】
================================================================================

Score = Final_Money (最终资金)

收益来源：
- 货物成功运送到泊位并装船
- 轮船执行 go 指令卖出货物

目标：在1000帧内尽可能多地赚取资金

================================================================================
【交互协议详解】
================================================================================

【每帧输入】程序从 stdin 读取：

<帧号> <当前金钱>
<场上货物数量>
<货物1_x> <货物1_y> <货物1_价值>
...
<机器人0_是否带货> <机器人0_x> <机器人0_y> <机器人0_状态>
...（共10个机器人）
<轮船0_状态> <轮船0_泊位ID>
...（共5艘轮船）
OK

【每帧输出】程序向 stdout 输出：

move <机器人ID> <方向>      # 方向: 0右 1左 2上 3下
get <机器人ID>              # 拾取货物
pull <机器人ID>             # 在泊位卸货
go <轮船ID>                 # 轮船出发卖货
OK

================================================================================
【地图说明】
================================================================================

地图字符：
  .  空地      - 机器人可通行
  *  海洋      - 机器人不可通行
  #  障碍      - 机器人不可通行
  A  起点      - 机器人初始位置（视为空地）
  B  泊位      - 机器人可在此卸货（也可通行）

坐标系：
  X轴（行）：垂直向下，范围 [0, 99]
  Y轴（列）：水平向右，范围 [0, 99]

================================================================================
【核心算法提示】
================================================================================

【路径规划 - BFS/A*】
问题：机器人如何从当前位置到达目标位置？

BFS实现框架：
```cpp
vector<vector<int>> bfs(int start_x, int start_y, int target_x, int target_y) {
    queue<pair<int,int>> q;
    vector<vector<bool>> visited(100, vector<bool>(100, false));
    vector<vector<pair<int,int>>> parent(100, vector<pair<int,int>>(100, {-1,-1}));
    
    q.push({start_x, start_y});
    visited[start_x][start_y] = true;
    
    int dx[] = {0, 0, -1, 1};  // 右左上下
    int dy[] = {1, -1, 0, 0};
    
    while (!q.empty()) {
        auto [x, y] = q.front();
        q.pop();
        
        if (x == target_x && y == target_y) {
            // 找到目标，回溯路径
            // TODO: 实现路径回溯
        }
        
        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];
            
            if (nx >= 0 && nx < 100 && ny >= 0 && ny < 100 &&
                !visited[nx][ny] && map[nx][ny] != '*' && map[nx][ny] != '#') {
                visited[nx][ny] = true;
                parent[nx][ny] = {x, y};
                q.push({nx, ny});
            }
        }
    }
}
```

【任务分配 - 贪心】
问题：哪个机器人去捡哪个货物？

简单策略：
- 为每个货物找最近的空闲机器人
- 优先处理高价值货物

进阶策略：
- 考虑机器人完成当前任务后的位置
- 多货物组合优化

【碰撞避免】
问题：多个机器人同时移动时避免碰撞

简化规则：
- 机器人不能移动到本帧开始时已有其他机器人的格子
- 即使其他机器人在本帧移走了，也不能移动到那个格子

解决方案：
- 记录每个机器人的目标位置
- 检测冲突并调整

================================================================================
【常见错误及解决】
================================================================================

错误1: 机器人移动失败
原因: 移动到障碍/海洋/其他机器人位置
解决: 使用BFS规划路径，检查目标格子是否可通行

错误2: get指令无效
原因: 机器人不在货物位置，或已经拿着货物
解决: 检查机器人坐标是否与货物坐标一致

错误3: pull指令无效
原因: 机器人不在泊位，或没拿货物
解决: 检查机器人是否在泊位格子（地图字符为'B'）

错误4: 两个机器人面对面走不动
原因: 互相阻塞（A要去B位置，B要去A位置）
解决: 让其中一个等待，或绕路

错误5: 得分很低
原因:
  - 机器人效率低（随机移动）
  - 没有及时让轮船出发卖货
  - 货物超时消失
解决: 实现BFS路径规划，定期执行go指令

================================================================================
【调试技巧】
================================================================================

1. 使用 cerr 输出调试信息（不影响判题）
   cerr << "Robot " << i << " at (" << x << ", " << y << ")" << endl;

2. 可视化当前状态
   cerr << "Frame: " << frame_id << ", Money: " << money << endl;

3. 检查地图
   运行gen_map.py后查看 maps/map1.txt，了解地图布局

4. 单步调试
   在关键决策点输出机器人的状态和决策

================================================================================
【文件说明】
================================================================================

你需要修改的文件：
  main.cpp                  你的调度算法实现

系统文件（不建议修改）：
  gen_map.py                地图生成器
  judge.py                  判题器
  智慧港口自动化调度系统题目.pdf  完整题目说明

生成的数据文件：
  maps/
    map1.txt                港口地图

================================================================================
【提交要求】
================================================================================

1. 提交文件：main.cpp
2. 提交文档：算法设计说明，需包含：
   - 路径规划算法说明（BFS/A*）
   - 任务分配策略
   - 冲突避免机制
   - 时间复杂度分析

================================================================================
【完整运行示例】
================================================================================

$ python gen_map.py
地图生成完成！
  文件: maps/map1.txt
  尺寸: 100 × 100
  机器人起点: 10 个
  泊位: 5 个

$ g++ main.cpp -o main

$ python judge.py
Starting Process: ./main
--- Simulation Start (Total Frames: 1000) ---
Frame 100: Money = 1250
Frame 200: Money = 3420
Frame 300: Money = 5680
Frame 400: Money = 8150
Frame 500: Money = 10500
Frame 600: Money = 12890
Frame 700: Money = 15200
Frame 800: Money = 17450
Frame 900: Money = 19800
Frame 1000: Money = 22100
--- Game Over ---
Final Score: 22100

================================================================================
